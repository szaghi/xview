!< xview, proc.input class definition.
module xview_file_procinput_object
!< xview, proc.input class definition.
use, intrinsic :: iso_fortran_env, only : stderr => error_unit
use penf
use stringifor

implicit none
private
public :: file_procinput_object

type :: file_procinput_object
   !< **File proc.input** class, parse, manipulate and emit Xnavis processors/blocks map file.
   type(string)              :: filename            !< Filename, proc.input generally, but it is customizable.
   integer(I4P)              :: blocks_number=0     !< Number of blocks.
   integer(I4P)              :: processors_number=0 !< Number of processors.
   integer(I4P), allocatable :: map(:,:)            !< Processors/blocks maps [1:4, 1:blocks_number] (blk, grp, bdy, proc).
   logical                   :: is_loaded=.false.   !< Flag for checking if the file has been correctly loaded.
   contains
      ! public methods
      procedure, pass(self) :: description     !< Return pretty-printed object description.
      procedure, pass(self) :: destroy         !< Destroy dynamic memory.
      procedure, pass(self) :: alloc           !< Allocate dynamic memory.
      procedure, pass(self) :: is_file_present !< Inquire if the file path is valid.
      procedure, pass(self) :: load_file       !< Load file.
      procedure, pass(self) :: processor_map   !< Return the map of a given processor.
      procedure, pass(self) :: save_file       !< Save file.
endtype file_procinput_object

contains
   pure function description(self) result(desc)
   !< Return a pretty-formatted object description.
   class(file_procinput_object), intent(in) :: self             !< File data.
   character(len=:), allocatable            :: desc             !< Description.
   integer(I4P)                             :: b                !< Counter.
   character(len=1), parameter              :: NL=new_line('a') !< New line character.

   if (self%is_loaded) then
      desc = 'generated by xview'//NL
      desc = desc//''//NL! record skipped
      desc = desc//''//NL! record skipped
      desc = desc//str(n=self%blocks_number, no_sign=.true.)//' number of blocks'//NL
      desc = desc//''//NL! record skipped
      desc = desc//''//NL! record skipped
      desc = desc//' block - group - body - processor'//NL
      do b=1, self%blocks_number
         desc = desc//str(n=self%map(:, b), no_sign=.true., separator=' ')//NL
      enddo
   else
      desc = 'warning: file "'//self%filename//'" not loaded!'
   endif
   endfunction description

   elemental subroutine destroy(self)
   !< Destroy dynamic memory.
   class(file_procinput_object), intent(inout) :: self !< File data.

   call self%filename%free
   self%is_loaded = .false.
   self%blocks_number = 0
   self%processors_number = 0
   if (allocated(self%map)) deallocate(self%map)
   endsubroutine destroy

   elemental subroutine alloc(self)
   !< Allocate dynamic memory.
   class(file_procinput_object), intent(inout) :: self !< File data.

   allocate(self%map(1:4, 1:self%blocks_number))
   endsubroutine alloc

  function is_file_present(self) result(is_present)
  !< Inquire if the file path is valid.
  class(file_procinput_object), intent(in) :: self       !< File data.
  logical                                  :: is_present !< Inquiring result.

  is_present = .false.
  if (self%filename/='') inquire(file=trim(adjustl(self%filename)), exist=is_present)
  endfunction is_file_present

   subroutine load_file(self, path, filename)
   !< Load file.
   class(file_procinput_object), intent(inout)        :: self      !< File data.
   character(*),                 intent(in), optional :: path      !< Path to mb.par.
   character(*),                 intent(in), optional :: filename  !< File name.
   character(:), allocatable                          :: path_     !< Path to mb.par, local variable.
   character(:), allocatable                          :: filename_ !< File name, local variable.
   integer(I4P)                                       :: file_unit !< Logical file unit.
   integer(I4P)                                       :: b         !< Counter.

   call self%destroy
   path_     = ''           ; if (present(path    )) path_     = trim(adjustl(path))
   filename_ = 'proc.input' ; if (present(filename)) filename_ = trim(adjustl(filename))
   self%filename = path_//filename_

   if (self%is_file_present()) then
      open(newunit=file_unit, file=trim(adjustl(self%filename)), action='read')
      read(file_unit, *) ! record skipped
      read(file_unit, *) ! record skipped
      read(file_unit, *) ! record skipped
      read(file_unit, *) self%blocks_number
      call self%alloc
      self%map = 0
      read(file_unit, *) ! record skipped
      read(file_unit, *) ! record skipped
      read(file_unit, *) ! record skipped
      do b=1, self%blocks_number
        read(file_unit,*) self%map(:, b)
      enddo
      close(file_unit)
      self%processors_number = maxval(self%map(4, :))
      self%is_loaded = .true.
   else
      write(stderr, "(A)")'error: file "'//trim(adjustl(self%filename))//'" not found!'
      self%is_loaded = .false.
   endif
   endsubroutine load_file

   function processor_map(self, processor) result(map)
   !< Return the map of a give processor.
   class(file_procinput_object), intent(in) :: self      !< File data.
   integer(I4P),                 intent(in) :: processor !< Processor queried.
   integer(I4P), allocatable                :: map(:,:)  !< Processor/blocks map.
   integer(I4P)                             :: Nb        !< Number of local blocks.
   integer(I4P)                             :: b         !< Counter.
   integer(I4P)                             :: c         !< Counter.

   if (allocated(self%map)) then
      Nb = 0
      do b=1, self%blocks_number
         if (self%map(4, b) == processor) Nb = Nb + 1
      enddo
      allocate(map(1:2, 1:Nb))
      map = 0
      c = 0
      do b=1, self%blocks_number
         if (self%map(4, b) == processor) then
            c = c + 1
            map(1, c) = self%map(2, b)
            map(2, c) = b
         endif
      enddo
   endif
   endfunction processor_map

   subroutine save_file(self, filename)
   !< Save file.
   class(file_procinput_object), intent(in)           :: self      !< File data.
   character(*),                 intent(in), optional :: filename  !< File name.
   integer(I4P)                                       :: file_unit !< Logical file unit.

   if (present(filename)) then
      open(newunit=file_unit, file=trim(adjustl(filename)), action='write')
   elseif (self%is_file_present()) then
      open(newunit=file_unit, file=trim(adjustl(self%filename)), action='write')
   else
      error stop 'error: nor "filename" neither "self%filename" have been specified for "file_procinput_object%save_file" method!'
   endif
   write(file_unit, *) self%description()
   close(file_unit)
   endsubroutine save_file
endmodule xview_file_procinput_object
